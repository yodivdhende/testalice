<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.0-next.11 ./site-animation.glb
-->

<script lang="ts">
	import { AnimationAction, AnimationMixer, AnimationObjectGroup, Group, LoopOnce, Material, Object3D } from 'three';
	import { T } from '@threlte/core';
	import { interactivity, useCursor, useGltf, useGltfAnimations } from '@threlte/extras';
	import SiteAnimation from '$lib/assets/gltf/site-animation.glb';
	import { Spring } from 'svelte/motion';
	import { mix } from 'three/tsl';

	interactivity();
	let { fallback, error, children, ref = $bindable(), ...props } = $props();
	const { onPointerEnter, onPointerLeave } = useCursor();
	ref = new Group();
	const gltf = useGltf<{
    nodes: Record<string, Object3D>,
    materials: Record<string, Material>,
  }>(SiteAnimation as string);
	const { actions, mixer } = useGltfAnimations(gltf, ref);
	const scales = {
		Sphere: new Spring(1),
		Sphere002: new Spring(1),
		Sphere003: new Spring(1),
		Sphere004: new Spring(1),
		Sphere006: new Spring(1),
		Sphere007: new Spring(1),
		Sphere008: new Spring(1)
	} as const;
	let started = $state(false);

  $effect(() => {
    spinSpheres();
  })

  
  function spinSpheres() {
    const sphereGroup = createSphereGroup();
    if(!sphereGroup) return;
    const clip = $actions['Spin']?.getClip();
    if(!clip) return;
    const spinAction = mixer.clipAction(clip, sphereGroup);
    console.log('action', spinAction);
    spinAction.play();
  }

  function createSphereGroup() {
    const nodes = $gltf?.nodes;
    if(!nodes) return null;
    const Objects = Object.entries($gltf?.nodes)
      .filter(([name, Object3D]) => name.includes('Sphere'))
      .map(([_name, Object3D]) => {
        Object3D.rotation.set(0, 0, 0);
        return Object3D;
    });
    return new AnimationObjectGroup(...Objects);
  }


	function start() {
		started = true;
		animateOnce($actions['CameraAction']);
    getSphereItemGroups().forEach(({group, animationName}) => {
      const clip = $actions[animationName]?.getClip();
      if(!clip) return;
      const sphereItemMixer = new AnimationMixer(group);
      animateOnce(sphereItemMixer.clipAction(clip));
    });
	}

  function getSphereItemGroups() {
    const nodes = $gltf?.nodes;
    if(!nodes) return [];
    return [
      {group: new AnimationObjectGroup(nodes.Sphere002, nodes.Torus002), animationName: 'Sphere2Move'},
      {group: new AnimationObjectGroup(nodes.Sphere003, nodes.Torus003), animationName: 'Sphere3Move'},
      {group: new AnimationObjectGroup(nodes.Sphere004, nodes.Torus007), animationName: 'Sphere4Move'},
      {group: new AnimationObjectGroup(nodes.Sphere006, nodes.Torus006), animationName: 'Sphere6Move'},
      {group: new AnimationObjectGroup(nodes.Sphere007, nodes.Torus007), animationName: 'Sphere7Move'},
      {group: new AnimationObjectGroup(nodes.Sphere008, nodes.Torus008), animationName: 'Sphere8Move'},

      // {group: new AnimationObjectGroup(nodes.Sphere002, nodes.Torus002), animationName: 'Sphere2Move'},
      // {group: new AnimationObjectGroup(nodes.Sphere003, nodes.Torus003), animationName: 'Sphere3Move'},
      // {group: new AnimationObjectGroup(nodes.Sphere004, nodes.Torus007), animationName: 'Sphere4Move'},
      // {group: new AnimationObjectGroup(nodes.Sphere006, nodes.Torus006), animationName: 'Sphere6Move'},
      // {group: new AnimationObjectGroup(nodes.Sphere007, nodes.Torus007), animationName: 'Sphere7Move'},
      // {group: new AnimationObjectGroup(nodes.Sphere008, nodes.Torus008), animationName: 'Sphere8Move'},
    ] ;
  }

	function animateOnce(action: AnimationAction | undefined) {
		if (!action) return;
		action.clampWhenFinished = true;
		action.setLoop(LoopOnce, 1).play();
	}

	function onHover(name: keyof typeof scales) {
		onPointerEnter();
		if (started === false) return;
		scales[name].target = 1.2;
	}

	function onUnHover(name: keyof typeof scales) {
		onPointerLeave();
		if (started === false) return;
		scales[name].target = 1;
	}
</script>

<T is={ref} dispose={false} {...props}>
	{#await gltf}
		{@render fallback?.()}
	{:then gltf}
		<T.Group name="Scene">
			<T.PerspectiveCamera
				name="Camera"
				makeDefault={true}
				far={100}
				near={0.1}
				fov={22.9}
				position={[7.07, 1, 7.06]}
				rotation={[0, Math.PI / 4, 0]}
			/>
			<T.DirectionalLight
				name="Sun"
				intensity={1}
				decay={2}
				position={[0, 21.62, 0]}
				rotation={[-Math.PI / 2, 0, 0]}
			>
				<T.Group position={[0, 0, -1]} />
			</T.DirectionalLight>
			<T.Group name="Spheres">
				<T.Mesh
					name="Sphere"
					geometry={gltf.nodes.Sphere.geometry}
					material={gltf.materials.Wireframe}
					position={[0, 1, 0]}
          rotation={[0, 0, 0]}
					onclick={start}
					scale={scales.Sphere.current}
					onpointerenter={() => onHover('Sphere')}
					onpointerleave={() => onUnHover('Sphere')}
				/>
				<T.Mesh
					name="Sphere002"
					geometry={gltf.nodes.Sphere002.geometry}
					material={gltf.materials.Wireframe}
					position={[0, 1, 0]}
          rotation={[0, 0, 0]}
					scale={scales.Sphere002.current}
					onpointerenter={() => onHover('Sphere002')}
					onpointerleave={() => onUnHover('Sphere002')}
				/>
				<T.Mesh
					name="Sphere003"
					geometry={gltf.nodes.Sphere003.geometry}
					material={gltf.materials.Wireframe}
					position={[0, 1, 0]}
          rotation={[0, 0, 0]}
					scale={scales.Sphere003.current}
					onpointerenter={() => onHover('Sphere003')}
					onpointerleave={() => onUnHover('Sphere003')}
				/>
				<T.Mesh
					name="Sphere004"
					geometry={gltf.nodes.Sphere004.geometry}
					material={gltf.materials.Wireframe}
					position={[0, 1.03, 0]}
					rotation={[0, 0, 0]}
					scale={scales.Sphere004.current}
					onpointerenter={() => onHover('Sphere004')}
					onpointerleave={() => onUnHover('Sphere004')}
				/>
				<T.Mesh
					name="Sphere006"
					geometry={gltf.nodes.Sphere006.geometry}
					material={gltf.materials.Wireframe}
					position={[0, 1, 0]}
					rotation={[0, 0, 0]}
					scale={scales.Sphere006.current}
					onpointerenter={() => onHover('Sphere006')}
					onpointerleave={() => onUnHover('Sphere006')}
				/>
				<T.Mesh
					name="Sphere007"
					geometry={gltf.nodes.Sphere007.geometry}
					material={gltf.materials.Wireframe}
					position={[0, 1, 0]}
					rotation={[0, 0, 0]}
					scale={scales.Sphere007.current}
					onpointerenter={() => onHover('Sphere007')}
					onpointerleave={() => onUnHover('Sphere007')}
				/>
				<T.Mesh
					name="Sphere008"
					geometry={gltf.nodes.Sphere008.geometry}
					material={gltf.materials.Wireframe}
					position={[0, 1, 0]}
					rotation={[0, 0, 0]}
					scale={scales.Sphere008.current}
					onpointerenter={() => onHover('Sphere008')}
					onpointerleave={() => onUnHover('Sphere008')}
				/>
			</T.Group>
			<T.Mesh
				name="Plane"
				geometry={gltf.nodes.Plane.geometry}
				material={gltf.materials.Floor}
				scale={58.28}
			/>
			<T.Mesh
				name="Torus"
				geometry={gltf.nodes.Torus.geometry}
				material={gltf.materials.lightring}
				position={[0, 0.01, 0]}
				scale={0.96}
			/>
			<T.Mesh
				name="Torus002"
				geometry={gltf.nodes.Torus002.geometry}
				material={gltf.materials['lightring.002']}
				position={[0, 0.01, 0]}
				scale={0.96}
			/>
			<T.Mesh
				name="Torus003"
				geometry={gltf.nodes.Torus003.geometry}
				material={gltf.materials['lightring.003']}
				position={[0, 0.01, 0]}
				scale={0.96}
			/>
			<T.Mesh
				name="Torus004"
				geometry={gltf.nodes.Torus004.geometry}
				material={gltf.materials['lightring.004']}
				position={[0, 0.01, 0]}
				scale={0.96}
			/>
			<T.Mesh
				name="Torus006"
				geometry={gltf.nodes.Torus006.geometry}
				material={gltf.materials['lightring.006']}
				position={[0, 0.01, 0]}
				scale={0.96}
			/>
			<T.Mesh
				name="Torus007"
				geometry={gltf.nodes.Torus007.geometry}
				material={gltf.materials['lightring.007']}
				position={[0, 0.01, 0]}
				scale={0.96}
			/>
			<T.Mesh
				name="Torus008"
				geometry={gltf.nodes.Torus008.geometry}
				material={gltf.materials['lightring.008']}
				position={[0, 0.01, 0]}
				scale={0.96}
			/>
		</T.Group>
	{:catch err}
		{@render error?.({ error: err })}
	{/await}

	{@render children?.({ ref })}
</T>
